package Analyzer;
import java_cup.runtime.*;
import AST.Expresion.*;
import java.util.LinkedList;


parser code
{:

  private Object AST;
  public Object GetAST(){
    return AST;
  }

  public void syntax_error(Symbol s){
          System.err.println("Error Sintáctico en la Línea " + (s.left) +" Columna "+s.right+ ". No se esperaba este componente: " +s.value+".");
  }
  /**
   * Método al que se llama en el momento en que ya no es posible una recuperación de errores.
   **/
  public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
          System.err.println("Error síntactico irrecuperable en la Línea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido.");
  }

:}

terminal s_Plus;
terminal s_Minus;
terminal s_Times;
terminal s_Divide;

terminal s_MayQ;
terminal s_MayIgQ;
terminal s_MenQ;
terminal s_MenIgQ;
terminal s_IgIg;
terminal s_dif;

terminal s_And;
terminal s_Or;
terminal s_Not;

terminal s_Par_Left;
terminal s_Par_Right;

terminal s_SemiColon;

terminal r_Verdadero;
terminal r_Falso;
terminal m_Entero;
terminal m_Decimal;
terminal m_Caracter;
terminal m_Cadena;
terminal m_Id;

non terminal Start;
non terminal Expresion terminals;
non terminal Expresion Exp; 
non terminal LinkedList<Expresion> L_Exp;

non terminal Expresion Exp_Aritmetica;
non terminal Expresion Exp_Relacional;
non terminal Expresion Exp_Logica;

precedence left  s_Plus, s_Minus;
precedence left  s_Times, s_Divide;
precedence left  s_MayQ, s_MayIgQ, s_MenQ, s_MenIgQ, s_IgIg, s_dif;
precedence right s_Not;
precedence left  s_Or;
precedence left  s_And;

start with Start;

Start ::= L_Exp:a               {: parser.AST = a;  :}
          ;

L_Exp ::=   L_Exp:a Exp:b       {: RESULT=a; RESULT.add(b); :}
          | Exp:a               {: RESULT = new LinkedList<Expresion>();  RESULT.add(a); :}
          ;


Exp ::=   Exp_Aritmetica:a                      {: RESULT = a;:}
        | Exp_Relacional:a                      {: RESULT = a;:}
        | Exp_Logica:a                          {: RESULT = a;:}
        | s_Par_Left Exp:a s_Par_Right          {: RESULT = a;:}
        | terminals:a                           {: RESULT = a;:}
        ;

Exp_Logica::=  Exp:a s_And Exp:b           {: RESULT = new And(a,b);            :} 
              |Exp:a s_Or  Exp:b           {: RESULT = new Or(a,b);             :}
              |    s_Not   Exp:a           {: RESULT = new Not(a);              :}
              ;          

Exp_Relacional::= Exp:a s_MayQ    Exp:b   {: RESULT = new MayorQue(a,b);        :}
                | Exp:a s_MayIgQ  Exp:b   {: RESULT = new MayorIgualQue(a,b);   :}
                | Exp:a s_MenQ    Exp:b   {: RESULT = new MenorQue(a,b);        :}
                | Exp:a s_MenIgQ  Exp:b   {: RESULT = new MenorIgualQue(a,b);   :}
                | Exp:a s_IgIg    Exp:b   {: RESULT = new Igualdad(a,b);        :}
                | Exp:a s_dif     Exp:b   {: RESULT = new Diferencia(a,b);      :}
                ;        

Exp_Aritmetica::= Exp:a s_Plus   Exp:b  {: RESULT = new Suma(a,b);           :}
                | Exp:a s_Minus  Exp:b  {: RESULT = new Resta(a,b);          :}
                | Exp:a s_Times  Exp:b  {: RESULT = new Multiplicacion(a,b); :}
                | Exp:a s_Divide Exp:b  {: RESULT = new Division(a,b);       :}
                ;

terminals::= m_Decimal:a                {: RESULT =  new Numerico(a);        :}
           | m_Entero:a                 {: RESULT =  new Numerico(a);        :}
           | m_Caracter:a               {: RESULT =  new Caracter(a);        :}                               
           | m_Cadena:a                 {: RESULT =  new Cadena(a);          :}
           | m_Id:a                     {: RESULT =  new Identificador(a);   :}
           | r_Verdadero:a              {: RESULT =  new Booleano(a);        :}
           | r_Falso:a                  {: RESULT =  new Booleano(a);        :}
           ;
